### 索引基本原理

##### 一、常用数据结构

| 数据结构                                      | 优缺点                                           | 常见应用                |
| --------------------------------------------- | ------------------------------------------------ | ----------------------- |
| 排序数组                                      | 实现简单，但性能差                               |                         |
| 哈希表                                        | 性能高，但内存消耗大                             | java语言的HashMap,mysql |
| 跳跃表                                        | 占用内存小且可调，对模糊查询表支持不好           | redis lucene3.0之前     |
| B树（B/B+/B*）                                | 磁盘索引，更新方便但检索速度较慢                 | 常用于关系型数据库      |
| 字典树                                        | 查询效率只跟字符串长度有关，但只适合英文词典     |                         |
| 双数组字典树                                  | 可做中文词典，内存占用小                         | 分词工具应用较多        |
| Finite State Transducers(FST)：有穷状态转换器 | 共享前缀，内存消耗小，但要求时输入有序，更新不易 | lucene                  |

##### 二、mysql数据库

![](https://tva1.sinaimg.cn/large/006tNbRwly1gblsbfqj5fj31d10u0gv3.jpg)

1. 非特殊情况，一律使用InnoDB引擎

2. 加了主键的表，其存储结构不再是顺序整齐的排列而是变成一课树

3. 索引种类：B-Tree B+-Tree hash 全文索引等，InnoDB引擎中，依赖表的组件星辰聚簇索引，说银河数据保存在同一个B+-Tree中，其他非聚簇索引，在叶子节点保存的实际上是主键，需要二次索引才能最终获得数据

4. B-Tree与B+-Tree区别：

   * 内部节点关键字个数与子树个数不同，B+相同，B的子树个数多一个
   *  B+所有指向文件的关键字及其指针都在叶子节点中;B有的指向文件的关键字是在内部节点中。B+，内部节点仅仅起到索引的作用
   *  B+一定要说说道叶子节点才行，B有可能中间直接返回

5. 联合索引
   * 列顺序决定索引优先级
   * 查询结果仅包含联合索引中的列，可直接返回结果，不需要再进行主键索引
   
6. 函数索引
   * 可以设置无传入变量的函数作为索引，比如date(commit_time)、substr(phone,1,3)，参数中包含变量的函数则无法预先索引
   * 函数索引通常不被推荐，非范式替代方案：适当冗余列
   
7. 索引合并

   * sql包含多个过滤条件可触发索引合并，and触发intersect merge,or 触发union merge
   * 如果条件很复杂，优化器会跳过merge
   * Before MySQL 5.6.6,范围查找（>，between等）不会参与merge
   * 相同的intersect merge经常出现，表示索引还有优化空间，单个索引合并成联合索引
   
8. 正确使用索引

   * 区分度高，低频修改，过滤和排序热点列
   * 区分度低但是几乎所有查询都会用到额列，可以用来做索引前缀，比如is_deleted
   * 过长字段建立索引时，只生成前缀索引（255字符），不推荐
   * 优化器尽可能多的选择索引列直到遇到范围条件，多个范围条件只有一条命中索引，范围条件可以替换成in的形式，但是多个in会形成笛卡尔积，使优化器耗时过多 超过一定量的in优化器又会跳过优化
   * 索引列与order by 子句一致，且所有列排序方向一致，才能用到索引
   * 关联多张表，只有所有排序字段都是第一张表时才能用到索引
   * InnoDB只有访问行时才会加锁，索引能有效减少访问行数，减少锁冲突
   * 页大小固定时（默认16k），索引字段占用的字节数越大，使用的页越多，io越多,碎片越多，尽量减短字段长度
   * 数字类型、原生日期类型比字符类型索引效率高

9. 优化sql

   * 正向查询而非负向，精确查询而非范围
   * 查询条件不包含运算
   * Like %不出现在最左边才会索引，如果前缀不够长，也会有性能问题
   * 不查不需要的字段
   * 倾斜字段不采用预编译变量而是直接写死
   * 批量操作分批执行，避免大事务
   * 尽量不使用关联查询
   * 避免大量数据排序
   * 一般来说，in比or快，exists比in快

##### 三、lucene索引原理

索引文件包含三个部分：词典、倒排表、正向文件+列式存储DocValues

![](https://tva1.sinaimg.cn/large/006tNbRwly1gblvgh9esqj30oo0gqjuc.jpg)



###### 1. 索引结构

luncene现在采用的数据结构为FST，他的特点：

1. 词查找复杂度为O(len(str))

2. 共享前缀、节省空间

3. 内存存放前缀索引、磁盘存放后缀词块

   ![](https://tva1.sinaimg.cn/large/006tNbRwly1gblvmxzz9mj30ml0dmgmj.jpg)

   tip部分，每列一个FST索引，所以会有多个FST，每个FST存放前缀和后缀块指针，这里前缀就为a、ab、ac。tim里面存放后缀块和词的其他信息如倒排表指针、TFDF等，doc文件里就为每个单词的倒排表。
   　　所以它的检索过程分为三个步骤：

   * 内存加载tip文件，通过FST匹配前缀找到后缀词块位置。

   * 根据词块位置，读取磁盘中tim文件中后缀块并找到后缀和相应的倒排表位置信息。

   * 根据倒排表位置去doc文件中加载倒排表

   已知FST要求输入有序，所以Lucene会将解析出来的文档单词预先排序，然后构建FST，我们假设输入为abd,abe,acf,acg，那么整个构建过程如下：

   ![](https://tva1.sinaimg.cn/large/006tNbRwly1gblvu6zeaaj30th0f2mz0.jpg)

   1. 插入abd时，没有输出。
   2. 插入abe时，计算出前缀ab，但此时不知道后续还会不会有其他以ab为前缀的词，所以此时无输出。
   3. 插入acf时，因为是有序的，知道不会再有ab前缀的词了，这时就可以写tip和tim了，tim中写入后缀词块d、e和它们的倒排表位置ip_d,ip_e，tip中写入a，b和以ab为前缀的后缀词块位置(真实情况下会写入更多信息如词频等)。
   4. 插入acg时，计算出和acf共享前缀ac，这时输入已经结束，所有数据写入磁盘。tim中写入后缀词块f、g和相对应的倒排表位置，tip中写入c和以ac为前缀的后缀词块位置。

   以上是一个简化过程，Lucene的FST实现的主要优化策略有：

   1. 最小后缀数。Lucene对写入tip的前缀有个最小后缀数要求，默认25，这时为了进一步减少内存使用。如果按照25的后缀数，那么就不存在ab、ac前缀，将只有一个跟节点，abd、abe、acf、acg将都作为后缀存在tim文件中。我们的10g的一个索引库，索引内存消耗只占20M左右。

   2. 前缀计算基于byte，而不是char，这样可以减少后缀数，防止后缀数太多，影响性能。如对宇(e9 b8 a2)、守(e9 b8 a3)、安(e9 b8 a4)这三个汉字，FST构建出来，不是只有根节点，三个汉字为后缀，而是从unicode码出发，以e9、b8为前缀，a2、a3、a4为后缀，如下图：

      ![](https://tva1.sinaimg.cn/large/006tNbRwly1gblw1o5gygj30e707bglw.jpg)

###### 2. 倒排表

倒排表就是文档号集合，但怎么存，怎么取也有很多讲究，Lucene现使用的倒排表结构叫Frame of reference,它主要有两个特点：

  1. 数据压缩，可以看下图怎么将6个数字从原先的24bytes压缩到7bytes。

     ![](https://tva1.sinaimg.cn/large/006tNbRwly1gblw3hd6vcj30fp0cm400.jpg)

  2.  跳跃表加速合并，因为布尔查询时，and 和or 操作都需要合并倒排表，这时就需要快速定位相同文档号，所以利用跳跃表来进行相同文档号查找。

###### 3. 正向文件

正向文件指的就是原始文档，Lucene对原始文档也提供了存储功能，它存储特点就是分块+压缩，fdt文件就是存放原始文档的文件，它占了索引库90%的磁盘空间，fdx文件为索引文件，通过文档号（自增数字）快速得到文档位置

###### 4. 列式存储DocValues

我们知道倒排索引能够解决从词到文档的快速映射，但当我们需要对检索结果进行分类、排序、数学计算等聚合操作时需要文档号到值的快速映射，而原先不管是倒排索引还是行式存储的文档都无法满足要求。

* 原先4.0版本之前，Lucene实现这种需求是通过FieldCache，它的原理是通过按列逆转倒排表将（field value ->doc）映射变成（doc -> field value）映射,但这种实现方法有着两大显著问题：
	1. 构建时间长。

	2. 内存占用大，易OutOfMemory，且影响垃圾回收。
* 因此4.0版本后Lucene推出了DocValues来解决这一问题，它和FieldCache一样，都为列式存储，但它有如下优点：
	1. 预先构建，写入文件。
	2. 基于映射文件来做，脱离JVM堆内存，系统调度缺页。
DocValues这种实现方法只比内存FieldCache慢大概10~25%，但稳定性却得到了极大提升。

Lucene目前有五种类型的DocValues：NUMERIC、BINARY、SORTED、SORTED_SET、SORTED_NUMERIC，针对每种类型Lucene都有特定的压缩方法。
如：

* 对NUMERIC类型即数字类型，数字类型压缩方法很多，如：增量、表压缩、最大公约数，根据数据特征选取不同压缩方法。
* SORTED类型即字符串类型，压缩方法就是表压缩：预先对字符串字典排序分配数字ID，存储时只需存储字符串映射表，和数字数组即可，而这数字数组又可以采用NUMERIC压缩方法再压缩，图示如下：

![](https://tva1.sinaimg.cn/large/006tNbRwly1gblw8rnhjcj30rv07m74t.jpg)

###### 四、Mysql 补充

1. Innodb File Format

   * mysql 相关参数：innodb_file_format 等
   * 可取值：
     * Antelope 
     * Barracuda(默认)

2. Innodb 引擎行存储格式

   * mysql 相关参数：innodb_default_row_format
   
   * 可选值：
     * compact
     * redundant
     * compressed
     * dynamic(mysql 5.7 默认)
     * fixed
     * default
   
   除了前面两种，后面的行格式使用时文件格式必须是 Barracuda
   
3. Mysql 类型占用字节

   | 类型      | 占用字节                        |
   | --------- | ------------------------------- |
   | datetime  | 5(两位小数多+一个字节，最多6位) |
   | timestamp | 4(两位小数多+一个字节，最多6位) |
   | date      | 3                               |
   | int       | 4                               |
   | tinyint   | 1                               |
   | mediumint | 3                               |
   | bigint    | 8                               |

   _补充：_mysql 一行限制 65535个直接，其中 NULL标志最少一个字节，如果varchar长度超过255需要两个字节，所以实际varchar最多65532个字节