### 一、HotSpot GC算法细节实现

1. **根节点枚举**

   * 准确式垃圾收集

     * OopMap:特定位置记录下栈里哪些是引用

   * 保守式垃圾收集
   
     无法确认到底是指针还是整数等其他类型，不可随意修改指针值即不可随意移动对象，妥协方案：采用句柄的形式，移动对象时修改句柄饿值，缺点是对象访问性能问题

2. **安全点**：为了节省空间，只在特定的位置记录记录OopMap信息，这些位置被称为安全点

    安全点选择标准：是否具有让程序长时间执行的特征  如：方法调用、循环跳转、异常处理等

    让线程跑到最近的安全点停顿：

    * 抢占式中断
    * 主动式中断（轮询代码精简至一条指令）

3. **安全区域**：某一段代码中引用关系不会发生变化（解决sleep等线程‘不执行’的场景）

	线程进入安全区时会标识自己，离开安全区时必须保证stop-the-world结束
	
4. **记忆集（RememberedSet）及卡表**

    解决跨代引用问题。卡表：记忆集的一种实现方式，hotspot中使用一个字节数组，每个元素标识内存区域的一块大小，存在跨代引用叫标记为1

5. **写屏障**：维护卡表的方法，可理解为赋值语句的AOP,分写前屏障和写后屏障

    伪共享问题：当多线程修改互相独立的变量时，如果这些变量恰好刚在同一个缓存行，就会互相影响导致性能降低

6. **并发的可达性分析**

    引入三种标记：

    * 白色：表示对象未被垃圾收集器访问过
    * 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过
    * 灰色：表示对象已经被垃圾收集器访问过，但至少有一个引用未被扫描

    对象消失问题必须满足两个条件：

    * 赋值器插入了一条或者多条从黑色对象到白色对象的引用
    * 赋值器删除了全部从灰色对象到该白色对象的直接或者间接引用

    解决方案：

    * 增量更新：破坏条件一，当黑色对象插入新的指向白色对象的引用关系时，将这个新引用记录下来，等并发扫描结束后重新以黑色节点为根扫描一次
    * 原始快照：破坏条件二，当灰色节点删除指向白色对象引用时，将这个要删除的引用记录下来，等并发扫描结束后重新以灰色为根扫描一次

### 二、经典垃圾收集器

| 名称              | 收集算法                                                     | 工作区域                                                     | 可配合对象                | 线程 | 并发     | 适用场合                                                     | 优缺点                                                      |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------- | ---- | -------- | ------------------------------------------------------------ | ----------------------------------------------------------- |
| Serial            | 复制算法                                                     | 新生代                                                       | Serial Old，CMS(jdk9取消) | 单   | 否       | 单CPU,客户端                                                 | 简单高效没有线程交互开销，需要STW                           |
| ParNew            | 复制                                                         | 新生代                                                       | CMS,Serial Old(jdk9取消)  | 多   | 否       | 多CPU,server端                                               | 多线程并行收集，需要STW                                     |
| Parallel Scavenge | 复制                                                         | 新生代                                                       | Serial Old,Parallel Old   | 多   | 否       | 追求吞吐量                                                   | 关注吞吐量                                                  |
| Serial Old        | 标记整理                                                     | 老年代                                                       | Serial，Parallel Scavenge | 单   | 否       | 与Parallel Scavenge，作为CMS收集器发生失败的后备方案         | STW                                                         |
| Parallel Old      | 标记整理                                                     | 老年代                                                       | Parallel Scavenge         | 多   | 否       | 配合Parallel Scavenge，吞吐量友好                            | STW                                                         |
| CMS               | 标记清楚                                                     | 老年代                                                       | ParNew，Serial(jdk9取消)  | 多   | 是       | B/S架构的服务端                                              | 低响应时间，cpu资源敏感，无法处理浮动垃圾，产生大量内存碎片 |
| G1                | 整体看是标记整理，局部看是标记复制                           | region（不同类型），逻辑上还是分新生代和老年代，但是是动态的region集合 | 无                        | 多   | 并发标记 | 面向服务端，在尽量保证用户期望的停顿时间的前提下尽量保证高吞吐量 | 可预测停顿时间，局部基于标记复制，性能好，不会产生垃圾碎片  |
| Shenandoah        | 大体同G1                                                     | 放弃分代                                                     | 无                        | 多   | 是       | 面向服务端，只有OpenJdk才能用                                | 做到了与用户线程一期并发回收                                |
| ZGC               | 基于Regison,不设分代，使用了读屏障、染色指针、内存多重映射等技术实现的标记整理算法 | 暂时不支持分代                                               | 无                        | 多   | 是       | 面向服务端，实验性质                                         | 采用了染色指针技术，缺点是没有分代，有浮动垃圾问题          |

### 二、方法调用

* 方法调用指令

  1. invokestatic：用于调用静态方法
  2. invokespecial：用于调用私有实例方法、构造器，以及使用super调用父类的实例方法和构造器，和所实现接口的默认方法
  3. invokevirtual：用于调用非私有实例方法
  4. invokeinterface：用于调用接口方法
  5. invokedynamic：用于调用动态方法
* 方法调用时，需将 符号引用 -> 实际引用
  * 静态绑定方法，实际引用为方法的一个指针
  * 动态绑定方法，实际引用为方法表的一个索引
* 方法表
  * 类加载【链接】阶段中，【准备】阶段生成的（准备阶段还会为静态字段分配内存）
  * 子类方发表包含父类方发表的所有方法，且重写父类方法的索引值相同